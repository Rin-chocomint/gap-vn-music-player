<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Efek Salju (WebGPU)</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="snow-canvas"></canvas>
    <script>
        (async () => {
            if (!navigator.gpu) {
                console.error("WebGPU tidak didukung.");
                return;
            }

            const canvas = document.getElementById('snow-canvas');
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');

            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
                alphaMode: 'premultiplied',
            });

            const mp = 75;

            // Data Awal
            const initialParticleData = new Float32Array(mp * 4);
            for (let i = 0; i < mp; i++) {
                initialParticleData[i * 4 + 0] = Math.random() * window.innerWidth; // x
                initialParticleData[i * 4 + 1] = Math.random() * window.innerHeight; // y
                initialParticleData[i * 4 + 2] = Math.random() * 2 + 0.5; // radius
                initialParticleData[i * 4 + 3] = Math.random() * mp; // density
            }

            // Setup Buffer Partikel
            // Kita bikin buffer penyimpanan (storage buffer) di GPU buat nyimpen data posisi & sifat tiap salju.
            // Buffer ini `mappedAtCreation: true` biar kita bisa tulis data awal langsung dari CPU (JavaScript).
            const particleBuffer = device.createBuffer({
                size: initialParticleData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true,
            });
            new Float32Array(particleBuffer.getMappedRange()).set(initialParticleData);
            particleBuffer.unmap(); // Jangan lupa unmap biar GPU bisa ambil alih kontrol buffer ini.

            const uniformBuffer = device.createBuffer({
                size: 32,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            // Struct Umum (Definisi Data)
            // Ini kayak 'interface' atau 'class' kalau di bahasa pemrograman biasa.
            // Kita harus pastiin struktur ini SAMA PERSIS antara JavaScript (saat ngisi buffer) dan WGSL (shader).
            // Kalau nggak sama, data bakal acak-acakan (misal posisi x kebaca sebagai radius).
            const commonCode = `
                struct Particle {
                    pos: vec2f,      // Posisi x, y (2 float)
                    radius: f32,     // Ukuran partikel (1 float)
                    density: f32,    // Kepadatan/berat untuk variasi gerak (1 float)
                };

                struct Uniforms {
                    screenSize: vec2f, // Ukuran layar (W, H)
                    angle: f32,        // Sudut global untuk angin/gerakan
                    mouseX: f32,       // Posisi mouse X
                    mouseY: f32,       // Posisi mouse Y
                };
            `;

            // Shader Komputasi
            const computeModule = device.createShaderModule({
                code: `
                    ${commonCode}
                    @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
                    @group(0) @binding(1) var<uniform> uniforms: Uniforms;

                    // Fungsi Hashing (Pseudo-Random Generator)
                    // Karena shader itu 'puera' math function dan ga punya state 'Math.random()',
                    // kita pake bitwise operation buat ngasilin angka acak dari sebuah input (seed).
                    // Rumus ini sering disebut 'PCG Hash' atau variannya, tujuannya bikin noise.
                    fn hash(value: u32) -> f32 {
                        var state = value;
                        state = state ^ 2747636419u;
                        state = state * 2654435769u;
                        state = state ^ (state >> 16u);
                        state = state * 2654435769u;
                        state = state ^ (state >> 16u);
                        state = state * 2654435769u;
                        return f32(state) / 4294967295.0; // Normalisasi ke range 0.0 - 1.0
                    }

                    @compute @workgroup_size(64)
                    fn computeMain(@builtin(global_invocation_id) global_id: vec3u) {
                        let index = global_id.x;
                        if (index >= arrayLength(&particles)) {
                            return;
                        }

                        var p = particles[index];

                        // Interaksi Mouse (Fisika Sederhana)
                        // Kita hitung vektor jarak (dx, dy) antara partikel dan mouse.
                        // Rumus Pythagoras: dist = sqrt(dx^2 + dy^2).
                        // Kalau partikel masuk radius mouse, kita 'dorong' menjauh.
                        
                        let dx = p.pos.x - uniforms.mouseX;
                        let dy = p.pos.y - uniforms.mouseY;
                        let dist = sqrt(dx * dx + dy * dy);
                        let mouseRadius = 100.0;

                        if (dist < mouseRadius) {
                            // Hitung gaya tolak. Semakin dekat = semakin kuat.
                            let force = (mouseRadius - dist) / mouseRadius * 3.0;
                            // Normalisasi arah (dx/dist, dy/dist) lalu kalikan kekuatan force.
                            p.pos.x += (dx / dist) * force;
                            p.pos.y += (dy / dist) * force;
                        }

                        // Gerakan
                        p.pos.y += cos(uniforms.angle + p.density) + 0.5 + p.radius / 4.0;
                        p.pos.x += sin(uniforms.angle) * 1.5;

                        // Cek Batas Layar (Reset Posisi)
                        // Kalau salju keluar layar (bawah atau samping), kita balikin ke atas/sisi lain.
                        // Ini teknik umum 'infinite scroll' partikel.
                        
                        let W = uniforms.screenSize.x;
                        let H = uniforms.screenSize.y;

                        if (p.pos.x > W + 5.0 || p.pos.x < -5.0 || p.pos.y > H) {
                            // Kita butuh posisi baru yang acak. Gunakan hash function tadi.
                            // Seed-nya kita gabungin ID partikel + waktu (angle) biar gak pola berulang.
                            let seed = u32(index) + u32(uniforms.angle * 100.0);
                            let randX = hash(seed);
                            let randY = hash(seed + 1u);
                            
                            // Logika reset agak pinter dikit:
                            // Sebagian besar reset ke atas layar (y = -10).
                            // Tapi kalau angin kencang (sin(angle)), kita spawn dari samping (x = 0 atau x = W)
                            if (index % 3u > 0u) {
                                p.pos.x = randX * W;
                                p.pos.y = -10.0;
                            } else {
                                if (sin(uniforms.angle) > 0.0) {
                                    p.pos.x = -5.0;
                                    p.pos.y = randY * H;
                                } else {
                                    p.pos.x = W + 5.0;
                                    p.pos.y = randY * H;
                                }
                            }
                        }
                        
                        particles[index] = p;
                    }
                `
            });

            // Shader Render
            const renderModule = device.createShaderModule({
                code: `
                    ${commonCode}
                    @group(0) @binding(0) var<storage, read> particles: array<Particle>;
                    @group(0) @binding(1) var<uniform> uniforms: Uniforms;

                    struct VertexOutput {
                        @builtin(position) position: vec4f,
                        @location(0) uv: vec2f,
                        @location(1) color: vec4f,
                    };

                    @vertex
                    fn vertexMain(
                        @builtin(vertex_index) vertexIndex: u32,
                        @builtin(instance_index) instanceIndex: u32
                    ) -> VertexOutput {
                        let p = particles[instanceIndex];
                        
                        // Trik Membangun Geometri di Shader (Vertex Pulling)
                        // Daripada kirim data verteks kotak (quad) dari CPU yang makan bandwidth,
                        // kita hardcode koordinat relatif kotak di sini.
                        // 6 verteks = 2 segitiga = 1 kotak.
                        var pos = array<vec2f, 6>(
                            vec2f(-1.0, -1.0), vec2f( 1.0, -1.0), vec2f(-1.0,  1.0), // Segitiga 1
                            vec2f(-1.0,  1.0), vec2f( 1.0, -1.0), vec2f( 1.0,  1.0)  // Segitiga 2
                        );
                        
                        // Transformasi Koordinat (Dunia ke Layar)
                        // 1. Ambil posisi dasar partikel (p.pos)
                        // 2. Tambah offset verteks lokal dikali radius (vPos * p.radius) biar jadi punya ukuran.
                        let worldPos = p.pos + vPos * p.radius;
                        
                        // 3. Konversi ke Clip Space (-1.0 s/d 1.0).
                        // WebGPU koordinatnya: x (-1 kiri, +1 kanan), y (-1 bawah, +1 atas).
                        // Tapi koordinat layar kita (0,0) di kiri-atas. Jadi perlu di-flip Y-nya.
                        
                        let x = (worldPos.x / uniforms.screenSize.x) * 2.0 - 1.0;
                        let y = -((worldPos.y / uniforms.screenSize.y) * 2.0 - 1.0); // Tanda minus (-) buat flip koordinat Y
                        
                        var out: VertexOutput;
                        out.position = vec4f(x, y, 0.0, 1.0);
                        out.uv = vPos;
                        out.color = vec4f(1.0, 1.0, 1.0, 0.4);
                        return out;
                    }

                    @fragment
                    fn fragmentMain(in: VertexOutput) -> @location(0) vec4f {
                        // Membuat Lingkaran Sempurna
                        // Kita terima koordinat UV (-1 s/d 1) dari vertex shader.
                        // Hitung panjang vektor dari titik tengah (length(in.uv)).
                        // Jika > 1.0, berarti di luar lingkaran -> buang pixelnya (discard).
                        // Jika <= 1.0, gambar warnanya.
                        let dist = length(in.uv);
                        if (dist > 1.0) {
                            discard;
                        }
                        return in.color;
                    }
                `
            });

            // Layout Bind Group
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX, buffer: { type: 'storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX, buffer: { type: 'uniform' } },
                ]
            });

            const computePipeline = device.createComputePipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                compute: { module: computeModule, entryPoint: 'computeMain' },
            });

            const renderPipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: { module: renderModule, entryPoint: 'vertexMain' },
                fragment: {
                    module: renderModule,
                    entryPoint: 'fragmentMain',
                    targets: [{
                        format: presentationFormat,
                        blend: {
                            color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                            alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                        },
                    }],
                },
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: uniformBuffer } },
                ],
            });

            let angle = 0;
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;

            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            function frame() {
                angle += 0.01;

                const uniformData = new Float32Array([
                    window.innerWidth, window.innerHeight, // ukuran layar
                    angle, // sudut
                    mouseX, mouseY, // mouse
                    0, 0, 0 // padding
                ]);
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                const commandEncoder = device.createCommandEncoder();

                // Pass Komputasi
                const computePass = commandEncoder.beginComputePass();
                computePass.setPipeline(computePipeline);
                computePass.setBindGroup(0, bindGroup);
                computePass.dispatchWorkgroups(Math.ceil(mp / 64));
                computePass.end();

                // Pass Render
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: { r: 0, g: 0, b: 0, a: 0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });
                renderPass.setPipeline(renderPipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(6, mp, 0, 0);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
        })();
    </script>
</body>

</html>